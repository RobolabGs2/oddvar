// Generated by https://quicktype.io

import * as fs from "fs";
import { BASE_STRATEGIES, ObjectFromEntries, RATING_STRATEGIES, STRATEGIES, StrategyName } from "./util";

export interface LaunchSettings {
	simulationID: string;
	settings: Settings;
	mapID: string;
	deadline: number;
	label: string;
}

export interface Settings {
	skin: string;
	errorRate: number;
	bots: Record<StrategyName, number>;
	strategies: Strategies;
	debug: Debug;
}

export interface Debug {
	network: boolean;
	map: boolean;
	botsThinking: boolean;
}

export interface Strategies {
	Скептик: Скептик;
}

export interface Скептик {
	threshold: number;
}

type Generator = (i: number) => number;
type GeneratorB = (i: number) => boolean;
namespace G {
	export const Const: (n: number) => Generator = (n) => () => n;
	export const ConstB: (n: boolean) => GeneratorB = (n) => () => n;
	export const Shift: (n: number) => Generator = (shift) => (i) => i + shift;
	export const Invert: (n: number) => Generator = (shift) => (i) => shift - i;
	export const Array: (arr: number[]) => Generator = (arr) => (i) => arr[i];
	export const CycledArray: (arr: number[]) => Generator = (arr) => (i) => arr[i % arr.length];
}

const Default: GeneratorFor<Settings> = {
	skin: "simple",
	errorRate: G.Const(0),
	bots: ObjectFromEntries<StrategyName, Generator>(STRATEGIES.map(x => [x, G.Const(0)])),
	strategies: {
		Скептик: {
			threshold: G.Const(0.5)
		}
	},
	debug: {
		network: G.ConstB(false),
		map: G.ConstB(false),
		botsThinking: G.ConstB(false)
	}
}

type RecursivePartial<T> = {
	[P in keyof T]?: RecursivePartial<T[P]>;
};

type SettingsGeneratorFull = typeof Default;
type SettingsGenerator = RecursivePartial<SettingsGeneratorFull>;

type GenerationResult<T> = {
	[P in keyof T]:
	T[P] extends string ? string :
	T[P] extends Generator ? number :
	T[P] extends GeneratorB ? boolean :
	T[P] extends object ? GenerationResult<T[P]> :
	unknown;
};

type GeneratorFor<T> = {
	[P in keyof T]:
	T[P] extends string ? string :
	T[P] extends number ? Generator :
	T[P] extends boolean ? GeneratorB :
	T[P] extends object ? GeneratorFor<T[P]> :
	unknown;
};


function ApplyGenerator<T>(i: number, generator: GeneratorFor<T>): T {
	const result = {} as T;
	for (let key in generator) {
		const g = generator[key];
		if (typeof g === "string") {
			result[key] = g as T[typeof key];
		} else if (typeof g === "function") {
			result[key] = g(i);
		} else {
			result[key] = ApplyGenerator<T[typeof key]>(i, g as GeneratorFor<T[typeof key]>);
		}
	}
	return result;
}

function FillFromDefault<T>(defaultValue: T, value: RecursivePartial<T>): T {
	for (let x in defaultValue) {
		const actual = value[x];
		if (actual === undefined) {
			value[x] = defaultValue[x];
			continue;
		}
		if (typeof value[x] === "object") {
			FillFromDefault(defaultValue[x], actual!);
			continue
		}
	}
	return value as T;
}

function GenerateQueue(label: string, g: SettingsGenerator, from: number = 0, to: number = 18, deadline = 1800, copies = 20): LaunchSettings[] {
	const generator = FillFromDefault(Default, g);
	const queue = new Array<LaunchSettings>();
	for (let i = from; i < to; i++) {
		const settings = ApplyGenerator(i, generator);
		const launch = {
			deadline, label, settings,
			simulationID: "multiagent",
			mapID: "symmetric",
		};
		for (let j = 0; j < copies; j++)
			queue.push(launch);
	}
	return queue;
}

function GenerateQueueForEachStrategy(label: string, strategy: Generator, g: SettingsGenerator = {}, from: number = 0, to: number = 18, strategies = STRATEGIES, deadline = 1800, copies = 20): LaunchSettings[] {
	return new Array<LaunchSettings>().concat(...strategies.map(x => {
		g.bots = {};
		g.bots[x] = strategy;
		return GenerateQueue(label, g, from, to, deadline, copies);
	}))
}

const errorRates = [0, 0.001, 0.005, 0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.8, 1];
const errorRatesQueue = GenerateQueueForEachStrategy("errors", G.Const(18), { errorRate: G.Array(errorRates) }, 0, errorRates.length, ["Честный_Скептик", "Лжец_Скептик"]);

function SaveQueue(name: string, queue: LaunchSettings[]) {
	console.log(`${name}: ${queue.length}`);
	fs.writeFileSync(`experiments/queue/${name}.json`, JSON.stringify(queue), { encoding: "utf-8" });
}

// SaveQueue("error_rates_skeptics", errorRatesQueue)
// SaveQueue("lier_4_vs_1_20_honesty", GenerateQueue("lier_4_vs_0_20_honesty", {
// 	bots: {
// 		Честный_Доверчивый: G.Shift(0),
// 		Лжец_Доверчивый: G.Const(4),
// 	}
// }, 1, 20))

function ErrorRangesHeterogen(tag: string, strategies: StrategyName[]) {
	const label = `error_rates_${tag}`;
	SaveQueue(label, GenerateQueue(label, {
		errorRate: G.Array(errorRates),
		bots: ObjectFromEntries<StrategyName, Generator>(strategies.map(x => [x, G.Const(18/strategies.length)])),
	}, 0, errorRates.length, 1800, 20))
}

ErrorRangesHeterogen("basic", BASE_STRATEGIES);
// ErrorRangesHeterogen("all", STRATEGIES);
// ErrorRangesHeterogen("rating", RATING_STRATEGIES);